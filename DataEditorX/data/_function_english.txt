#####################################################
# The data types used in the script are the following:
# Int: Integer type
# Bool: Boolean type (true or false)
# String: String
# Function: Function
# Card: The card class
# Effect: The effect class
# Group: The deck class
# Nil: empty type, also said that the empty variables (only that meaningful empty return value)
# Any: any type
# In order to facilitate the description, the use of similar C function representation
# [] Indicates that there are default values ​​that can be omitted
# Indicate only meaningful nil type parameters or return values
#
# Note: Regarding the filter condition function
# The filter condition function is the function whose first argument is of type Card and whose return value is boolean. This function is used to retrieve calls in a filter function that meets the criteria for a deck. The filter condition function can have indefinite parameters, and the second start parameter is obtained from the extra parameters of the filter function. For example:
# Function sample_filter (c, atk, def)
# Return c: GetAttack ()> = atk and c: GetDefense ()> = def
# End
# This function returns true if attack power> = atk and defence> = def for a card c, otherwise false
# G = Duel.GetFieldGroup (0, LOCATION_HAND, 0) - Grab Player 1's Hand Card
# Fg = g: Filter (sample_filter, nil, 1000,500) - Select the attack power> = 1000 from g and the card with> = 500
# Group.Filter only three parameters, the first four parameters start as additional parameters, additional parameters will be passed to the sample_filter
#
# Note: Regarding the specified position
# Some functions can get the specified location of the card, through the three parameters specified int player, int s, int o
# S refers to the player's player's own side of the position, o refers to the player's player for each other's position
# Such as Duel.GetFieldGroup (0, LOCATION_GRAVE, LOCATION_MZONE)
# Return all cards of player 0's cemetery and player's monster zone
#
# Note: For description
# Script system is not directly use the string display prompt text, but by the system through an integer (int desc) to find the appropriate description
# For desc <2048, the system looks for it in string.conf, where some commonly used numbers (usually the prompt text) are recorded in constant.lua
# For desc> 10000, the system looks for a description in the card database, usually specified with the aux.Stringid () function
####################################################
●void initial_effect(Card c)
Called when the card is loaded
General is to register the initial card effect, and set the Soviet students limit and so on
========== bit ===========
●int bit.band(int a, int b)
A and b with the bit
●int bit.lshift(int a, int b)
A Move to the left b
●int bit.bor(int a, int b)
A or b
●int bit.rshift(int a, int b)
A Move to the right b
●int bit.bxor(int a, int b)
A and b bit XOR
●int bit.bnot(int a)

●int bit.extract(int r, int field, int width)

●int bit.replace(int r, int v, int field, int width)

========== Card ==========
●int[,int] Card.GetCode(Card c)
Returns the current codename for c (possibly because the effect changes)
●int Card.GetOriginalCode(Card c)
Returns the code number of the card in c
●int,int Card.GetOriginalCodeRule(Card c)
Returns the codename on the c rule (used as a card rule on this card)
●int[,int,...] Card.GetFusionCode(Card c)
Return c as the fusion material when the card number (including the original c card number)
●int[,int,...] Card.GetLinkCode(Card c)

●bool Card.IsFusionCode(Card c, int code[,...])
Check the c as a fusion material can be used as the card number for the code card
●bool Card.IsLinkCode(Card c, int code[,...])

●bool Card.IsSetCard(Card c, int setname)
Check whether c is a card with the name setname
●bool Card.IsOriginalSetCard(Card c, int setname)

●bool Card.IsPreviousSetCard(Card c, int setname)
Check whether the name c contains a setname before the c position changes
●bool Card.IsFusionSetCard(Card c, int setname)
Check the c as a fusion material can be used as a name setname card
●bool Card.IsLinkSetCard(Card c, int setname)

●int Card.GetType(Card c)
Returns the current type of c
●int Card.GetOriginalType(Card c)
Returns the type of card entry for c
●int Card.GetFusionType(Card c)

●int Card.GetSynchroType(Card c)

●int Card.GetXyzType(Card c)

●int Card.GetLinkType(Card c)

●int Card.GetLink(Card c)

●int Card.GetLevel(Card c)
Returns the current level of c
●int Card.GetRank(Card c)
Returns the current class of c
●int Card.GetSynchroLevel(Card c, Card sc)
Return to the co-ordination of c with the call monster sc with the level
This function returns the same value as Card.GetLevel(c) except for certain cards such as modems.
●int Card.GetRitualLevel(Card c, Card rc)
Returns the ritual liberation level for rc ritual monsters
This function returns the same value as Card.GetLevel(c) except for certain cards such as ritual objects
●int Card.GetOriginalLevel(Card c)
Returns the rank of the card in c
●int Card.GetOriginalRank(Card c)
Returns the class of the card in c
●bool Card.IsXyzLevel(Card c, Card xyzc, int lv)
Check c for excess monster xyzc with the level of whether the excess is lv
●int Card.GetLeftScale(Card c)
Returns the left-hand pendulum scale of c
●int Card.GetOriginalLeftScale(Card c)
Returns the original left-hand pendulum scale of c
●int Card.GetRightScale(Card c)
Returns the right-hand pendulum scale of c
●int Card.GetCurrentScale(Card c)

●int Card.GetOriginalRightScale(Card c)
Returns the original right pendulum scale of c
●bool Card.IsLinkMarker(Card c, int dir)

●Group Card.GetLinkedGroup(Card c)

●int Card.GetLinkedGroupCount(Card c)

●int Card.GetLinkedZone(Card c[, int player = c:GetControler()])

●Group Card.GetMutualLinkedGroup(Card c)

●int Card.GetMutualLinkedGroupCount(Card c)

●int Card.GetMutualLinkedZone(Card c[, int player = c:GetControler()])

●bool Card.IsLinkState(Card c)

●bool Card.IsExtraLinkState(Card c)

●Group Card.GetColumnGroup(Card c[,int left = 0, int right = 0])

●int Card.GetColumnGroupCount(Card c[,int left = 0, int right = 0])

●int Card.GetColumnZone(Card c, int location[, int left, int right, int player])

●bool Card.IsAllColumn(Card c)

●int Card.GetAttribute(Card c)
Returns the current attribute of c
Note: For some multi-attribute monsters such as light and dark dragon, the return value of this function may be a combination of several properties of the value
●int Card.GetAttributeInGrave(Card c)

●int Card.GetOriginalAttribute(Card c)
Returns the attributes of the card that c is describing
●int Card.GetFusionAttribute(Card c[, int player])

●int Card.GetLinkAttribute(Card c[, int player])

●int Card.GetRace(Card c)
Returns the current race of c
Note: For some multi-ethnic monsters such as animation effects of the magic ape, the function of the return value may be a combination of several racial values
●int Card.GetRaceInGrave(Card c)

●int Card.GetOriginalRace(Card c)
Returns the c of the card record race
●int Card.GetLinkRace(Card c[, int player])

●int Card.GetAttack(Card c)
Return the current attack power of c, the return value is a negative that is "?"
●int Card.GetBaseAttack(Card c)
Return the original attack power of c
●int Card.GetTextAttack(Card c)
Returns the attack power recorded on card c
●int Card.GetDefense(Card c)
Returns the current defense of c, the return value is negative that is "?"
●int Card.GetBaseDefense(Card c)
Return to the original c of the defense
●int Card.GetTextDefense(Card c)
Return the c 's card record of the garrison
●int[,int] Card.GetPreviousCodeOnField(Card c)
Returns the card number prior to the c position change
●int Card.GetPreviousTypeOnField(Card c)
Returns the type before the c position change
●int Card.GetPreviousLevelOnField(Card c)
Returns the rank before the c position change
●int Card.GetPreviousRankOnField(Card c)
Returns the class before the c position changes
●int Card.GetPreviousAttributeOnField(Card c)
Returns the attribute before the c position change
●int Card.GetPreviousRaceOnField(Card c)
Returns the race before the c position changes
●int Card.GetPreviousAttackOnField(Card c)
Returns the attack power before the c position changes
●int Card.GetPreviousDefenseOnField(Card c)
Returns the defensive power before the c position changes
●int Card.GetOwner(Card c)
Returns the holder of c
●int Card.GetControler(Card c)
Returns the current controller of c
●int Card.GetPreviousControler(Card c)
Returns the controller before the position change of c
●void Card.SetReason(Card c, int reason)

●int Card.GetReason(Card c)
Returns the position change reason for c
●Card Card.GetReasonCard(Card c)
Returns the card that caused the position of c to change
This function is only valid when a card is destroyed by a battle, because the superior call is released, or becomes a special call to use the material
●int Card.GetReasonPlayer(Card c)
Returns the player that caused the position of c to change
●Effect Card.GetReasonEffect(Card c)
Returns the effect that causes the position of c to change
●int Card.GetPosition(Card c)
Returns the current representation of c
●int Card.GetPreviousPosition(Card c)
Returns the representation of the position before the c position changes
●int Card.GetBattlePosition(Card c)
Returns the representation of c before this battle occurs
●int Card.GetLocation(Card c)
Returns the current position of c
●int Card.GetPreviousLocation(Card c)
Returns the position before the c position changes
●int Card.GetSequence(Card c)
Returns the serial number of the current position
In the field, the sequence number on behalf of the grid, from left to right are 0-4, the venue magic number is 5, left and right pendulum area is 6-7
In other places, the serial number represents the first card, the lowest card number is 0
●int Card.GetPreviousSequence(Card c)
Returns the sequence number before the c position changes
●int Card.GetSummonType(Card c)
Returns the call / special call of c
●int Card.GetSummonLocation(Card c)
Returns the call position of c
●int Card.GetSummonPlayer(Card c)
Return to Summoner / Special Summoner c Players
●int Card.GetDestination(Card c)
Returns the destination of the c position change
This function is valid only when processing position transitions instead of effects
●int Card.GetLeaveFieldDest(Card c)
Returns the destination of an effect (such as the universe) that was changed as a result of departure from c
●int Card.GetTurnID(Card c)
Return c The round to the current position
●int Card.GetFieldID(Card c)
Returns the time stamp of the transition to the current position
This value is unique, the smaller the c is the earlier appear in that position
Opening the card from the inside will also change this value
●int Card.GetRealFieldID(Card c)
Returns the actual timestamp for the c transition to the current position
Opening the card from the inside does not change this value
●bool Card.IsCode(Card c, int code1[, int code2,...])
Check whether the card number c is code1[, or code2 ...]
●bool Card.IsType(Card c, int type)
Check if c is of type type
●bool Card.IsExtraDeckMonster(Card c)

●bool Card.IsFusionType(Card c, int type)

●bool Card.IsSynchroType(Card c, int type)

●bool Card.IsXyzType(Card c, int type)

●bool Card.IsLinkType(Card c, int type)

●bool Card.IsLevel(Card c, int level1[, int level2,...])

●bool Card.IsRank(Card c, int rank1[, int rank2,...])

●bool Card.IsLink(Card c, int link1[, int link2,...])

●bool Card.IsAttack(Card c, int atk1[, int atk2,...])

●bool Card.IsDefense(Card c, int def[, int atk2,...])

●bool Card.IsRace(Card c, int race)
Check if c is race race
●bool Card.IsLinkRace(Card c, int race[, int player])

●bool Card.IsAttribute(Card c, int attribute)
Check whether c belongs to attribute attribute
●bool Card.IsFusionAttribute(Card c, int attribute[, int player])

●bool Card.IsLinkAttribute(Card c, int attribute[, int player])

●bool Card.IsReason(Card c, int reason)
Check if c contains the reason
●bool Card.SetReason(Card c, int reason)

●bool Card.IsSummonType(Card c, int sumtype)

●bool Card.IsSummonLocation(Card c, int location)

●bool Card.IsSummonPlayer(Card c, int player)

●bool Card.IsStatus(Card c, int status)
Check whether c contains a status code
●bool Card.IsNotTuner(Card c)
Check whether c can be used as a non-adjustment
●void Card.SetStatus(Card c, int state, bool enable)
Set or cancel the status code for c
Do not use this function unless you clearly understand the meaning of each status code
●bool Card.IsDualState(Card c)
Check whether c is in the re-call state
●void Card.EnableDualState(Card c)
Set c to re-call state
●void Card.SetTurnCounter(Card c, int counter)
Set c of the round counter (light of the sword, etc.)
●int Card.GetTurnCounter(Card c)
Returns the round counter for c
●void Card.SetMaterial(Card c, Group g)
The g of all the cards as the c material (superior summon, special summon)
●Group Card.GetMaterial(Card c)
Returns the material used for the appearance of c
●int Card.GetMaterialCount(Card c)
Returns the amount of material used for c appearance
●Group Card.GetEquipGroup(Card c)
Returns the current set of cards
●int Card.GetEquipCount(Card c)
Returns the number of cards currently loaded
●Card Card.GetEquipTarget(Card c)
Returns the current artefact object
●Card Card.GetPreviousEquipTarget(Card c)
Returns the device object before c
●bool Card.CheckEquipTarget(Card c1, Card c2)
Check whether c2 is the correct equipment object for c1
## Determined by the EFFECT_EQUIP_LIMIT effect or confederation state
●int Card.GetUnionCount(Card c)
Returns the number of ally cards for the current device
●Card Card.CheckUnionTarget(Card c, Card ec)

●Group Card.GetOverlayGroup(Card c)
Returns the currently stacked deck
●int Card.GetOverlayCount(Card c)
Returns the number of cards currently stacked
●Card Card.GetOverlayTarget(Card c)
Returns the card with c as the excess material
●bool Card.CheckRemoveOverlayCard(Card c, int player, int count, int reason)
Check the player player can be reason for the reason, at least remove the c stacked count cards
●int Card.RemoveOverlayCard(Card c, int player, int min, int max, int reason)
For reason reason, let players player remove c stacked min-max card, the return value that is successful
●Group Card.GetAttackedGroup(Card c)
Returns the card set attacked by this turn
●int Card.GetAttackedGroupCount(Card c)
Returns the number of cards that have been attacked this turn
●int Card.GetAttackedCount(Card c)
Returns the number of times this round has been attacked
Note: If this value is different from the return value of the previous function, then this card has been a direct attack this round
●Group Card.GetBattledGroup(Card c)
Returns the deck of the card that fought this turn
Fighting has occurred in the calculation of the damage occurred, for the sword and other animals, animal judgments
●int Card.GetBattledGroupCount(Card c)
Returns the number of cards battled for this turn
●int Card.GetAttackAnnouncedCount(Card c)
Returns the number of times this declaration was asserted
Note: Attack is invalid will not count the number of attacks, but will be counted into the number of attacks on the Declaration
●bool Card.IsDirectAttacked(Card c)
Check whether c direct attack
●void Card.SetCardTarget(Card c1, Card c2)
C2 as the perpetual object of c1
C1 and c2 of the contact will c1 or c2 any one card to leave or become the side of that reset
●Group Card.GetCardTarget(Card c)
Returns all currently persistent objects
●Card Card.GetFirstCardTarget(Card c)
Returns c the current first persistent object
●int Card.GetCardTargetCount(Card c)
Returns the number of current persistent objects
●bool Card.IsHasCardTarget(Card c1, Card c2)
Check whether c1 takes c2 as a persistent object
●void Card.CancelCardTarget(Card c1, Card c2)
Cancel c2 as a perpetual object of c1
●Group Card.GetOwnerTarget(Card c)
Returns all cards with c as the persistent object
●int Card.GetOwnerTargetCount(Card c)
Returns the number of cards that take c as the persistent object
●Effect,... Card.GetActivateEffect(Card c)
Returns the effect of the "card firing" of c, that is, the effect of type EFFECT_TYPE_ACTIVATE
Only for magic and traps
●Effect[,Group,int,int,Effect,int,int] Card.CheckActivateEffect(Card c, bool neglect_con, bool neglect_cost, bool copy_info)
Return to the timing of the launch of the correct c "card launch" effect, ignored_con = true ignoring the launch conditions, ignored_cost = true ignoring the launch cost
Copy_info = false or the free-time effect only returns the effect
Otherwise return the effect of the time point for the code when the trigger point information eg, ep, ev, re, r, rp
●void|Effect[,function,int,int,int] Card.GetTunerLimit(Card c)

●void|Effect[,function,int,int] Card.GetHandSynchro(Card c)

●int Card.RegisterEffect(Card c, Effect e[, bool forced = false])
Register the effect e to c, return the global id of the effect, and set the Handler of e to c
By default, if c is registered with the effect of immune e then the registration will fail
If forced is true, the immune effect of c against e will not be checked
●... Card.IsHasEffect(Card c, int code)
Check if c is affected by the effect type
●... Card.GetCardEffect(Card c, int code)

●void Card.ResetEffect(Card c, int reset_code, int reset_type)
To reset the type to reset_type, reset the type reset_code manual reset c impact of the impact
The reset_type can only be one of the following types, and the corresponding reset type is
RESET_EVENT An event reset_code is set for the event
RESET_PHASE End of phase Reset the reset_code to phase
RESET_CODE reset the effect of the specified code reset_code for the type of effect code, can only be reset EFFECT_TYPE_SINGLE sustainable type effect
RESET_COPY resets the effect of the copy. Reset_code is copy_id
RESET_CARD The effect of resetting the card reset_code is the card number of the effect owner
●int Card.GetEffectCount(Card c, int code)
Returns the number of effects that c is affected by the type of code
●Effect Card.RegisterFlagEffect(Card c, int code, int reset_flag, int property, int reset_count[, int label, int desc])
For the registration of a logo with the results
Note: The effect of the registration to the card is not used for the system,
Even if the code and the built-in effect code coincidence will not affect,
And the type is always EFFECT_TYPE_SINGLE, reset method, property, and the general effect of the same,
And will not be invalidated, immune effect from the card
●int Card.GetFlagEffect(Card c, int code)
The type of returned c is the number of identifying effects of the code
●void Card.ResetFlagEffect(Card c, int code)
Manually clear the type of c is the code of the identification effect
●bool Card.SetFlagEffectLabel(Card c, int code, int label)
Returns whether or not c has an identifier of type code, and sets its Label property to label
●int[,...] Card.GetFlagEffectLabel(Card c, int code)
The type of c is the label that identifies the effect of code, and returns nil if it does not
●void Card.CreateRelation(Card c1, Card c2, int reset_flag)
For c1 established in c2 contact this contact, only because c1 occurred RESET_EVENT the event reset
●void Card.ReleaseRelation(Card c1, Card c2)
Manually release c1 for c2
●void Card.CreateEffectRelation(Card c, Effect e)
For the card c and the effect of e to establish contact
●void Card.ReleaseEffectRelation(Card c, Effect e)
Manually release the link between c and effect e
●void Card.ClearEffectRelation(Card c)
Clear all the effects of c contact
●bool Card.IsRelateToEffect(Card c, Effect e)
Check whether c is associated with effect e
Note: Each launch into the effect of chain, the effect of launching the card, and the effect of the specified object
(With Duel.SetTargetCard or Duel.SelectTarget specified, including the take and not take objects)
●bool Card.IsRelateToChain(Card c, int chainc)
Check if c is linked to chained chainc
Note: Each launch into the effect of chain, the effect of launching the card, and the effect of the specified object
(With Duel.SetTargetCard or Duel.SelectTarget specified, including the take and not take objects)
Will automatically establish contact with that effect, once the departure, contact will be reset
●bool Card.IsRelateToCard(Card c1, Card c2)
Check whether c1 and c2 are linked
●bool Card.IsRelateToBattle(Card c)
Check whether c is associated with this battle
Note: This effect is usually used for damage calculation before the end of the injury phase, used to check whether the fighting off the card too
●int Card.CopyEffect(Card c, int code, int reset_flag[, int reset_count = 1])
Adding a card number for c is the replicable effect of the card's code, and adding an additional reset condition
The return value is the code id representing the copy effect
●int Card.ReplaceEffect(Card c, int code, int reset_flag[, int reset_count = 1])
Replace the effect of c with the effect of the card whose card number is code, and add additional reset conditions
The return value is the code id representing the replacement effect
●void Card.EnableReviveLimit(Card c)
Add a limit to the cs for c
## Actually is not copyable and will not be affected by invalid EFFECT_UNSUMMONABLE_CARD and EFFECT_REVIVE_LIMIT effects
●void Card.CompleteProcedure(Card c)
So that c to complete the formal call procedures
## This function can also be implemented with Card.SetStatus
●bool Card.IsDisabled(Card c)
Check whether c is in an invalid state
●bool Card.IsDestructable(Card c[, Effect e])
Check whether c is destructible
●bool Card.IsSummonableCard(Card c)
Check whether c is a card that can be called normally
●bool Card.IsSummonLocation(Card c, int loc)

●bool Card.IsSummonPlayer(Card c, int player)

●bool Card.IsFusionSummonableCard(Card c[, int sum_type])

●bool Card.IsSpecialSummonable(Card c[, int sum_type])
Check if you can make a special call to c
●bool Card.IsSynchroSummonable(Card c, Card tuner|nil[, Group mg])
Check whether tuner can be used as an adjustment, the field card [or mg] for the coherent material on the c cohomology summon procedures
If the tuner is nil, this function has the same effect as Card.IsSpecialSummonable
●bool Card.IsXyzSummonable(Card c, Group mg|nil[, min = 0, max = 0])
Check whether mg can be selected in the [min-max months] excessive material on the c to call the excess procedure
If mg is nil, this function has the same effect as Card.IsSpecialSummonable
●bool Card.IsSummonable(Card c, bool ignore_count, Effect e|nil[, int min = 0, int zone = 0x1f])
Check whether c is usually called (not including the normally called set), ignore_count = true does not check the number of calls limit
E ~ = nil check whether c can be the effect of e is usually called, min said at least the number of sacrifice (used to distinguish between compromise summons and superior call)
●bool Card.IsMSetable(Card, bool ignore_count, Effect e|nil[, int min = 0, int zone = 0x1f])
Check whether c can be normally called set, ignore_count = true does not check the number of calls limit
E ~ = nil then check whether c can be the effect of e is usually called set, min that at least the number of sacrifices needed (used to distinguish between compromise summoned set and superior summoned set)
●bool Card.IsSSetable(Card c[, bool ignore_field = false])
Check whether c can be set to the magic trap area, ignore_field = true is disregard of the trap area trap trap
●bool Card.IsCanBeSpecialSummoned(Card c, Effect e, int sumtype, int sumplayer, bool nocheck, bool nolimit[, int sumpos = POS_FACEUP, int toplayer = sumplayer, int zone = 0xff])
Check whether c can be sumplayer with the effect of the player e to sumtype form sumpos special summon to target_player field
If nocheck is true, the call condition of c is not checked, and if nolimit is true, then the limit of c is not checked
●bool Card.IsAbleToHand(Card c)
Check whether c can hand
Note: This function returns false only if the card or player is affected by the effect of being unable to join the hand (such as Ray King)
# # The following functions are similar
●bool Card.IsAbleToDeck(Card c)
Check whether c can be sent to the card group
●bool Card.IsAbleToExtra(Card c)
Check if c can send extra cards
This function returns false for non-fusion, cohomology, and overdrive cards
●bool Card.IsAbleToGrave(Card c)
Check whether c can be sent to the cemetery
●bool Card.IsAbleToRemove(Card c[, int player])
Check whether c can be player except player
●bool Card.IsAbleToHandAsCost(Card c)
Check whether c can be sent as the cost of hand cards
Note: This function appends the actual destination of c to Card.IsAbleToHand
This function returns false when c is sent to the other hand (if the retraction loop is applicable, or c is a blend, cohomology, and oversize)
# # The following functions are similar
●bool Card.IsAbleToDeckAsCost(Card c)
Check whether c can be sent to the card as a cost group
●bool Card.IsAbleToExtraAsCost(Card c)
Check whether c can be sent as an additional cost card group
●bool Card.IsAbleToDeckOrExtraAsCost(Card c)
Check whether c can be sent as a cost card group or additional card group (for the new Yu-xia, sword fighting beast fusion call monster detection procedures)
●bool Card.IsAbleToGraveAsCost(Card c)
Check whether c can be sent to the cemetery as a cost
●bool Card.IsAbleToRemoveAsCost(Card c)
Check whether c can be excluded as a cost
●bool Card.IsAbleToDecreaseAttackAsCost(Card c[, int atk])

●bool Card.IsAbleToDecreaseDefenseAsCost(Card c[, int def])

●bool Card.IsReleasable(Card c)
Check whether c can be liberated (non-superior call)
●bool Card.IsReleasableByEffect(Card c)
Check whether c can be liberated by the effect
●bool Card.IsDiscardable(Card[, int reason = REASON_COST])
Check whether c can be discarded
Note: This function is only used to detect,
REASON_DISCARD as a reason to hand a card to the tomb and will not lead to that card can not be discarded
●bool Card.IsAttackable(Card c)
Check whether c can attack
●bool Card.IsChainAttackable(Card c[, int ac = 2, bool monsteronly = false])
Check whether c can be a continuous attack, c the number of attacks declared> = ac return false
Note: This function returns false when c has made multiple attacks due to effects such as flashing swords
●bool Card.IsFaceup(Card c)
Check whether c is a surface-side representation
●bool Card.IsAttackPos(Card c)
Check whether c is an attack
●bool Card.IsFacedown(Card c)
Check whether c is the backside representation
●bool Card.IsDefensePos(Card c)
Check whether c is a defensive representation
●bool Card.IsPosition(Card c, int pos)
Check whether c is the representation pos
●bool Card.IsPreviousControler(Card c,int player)

●bool Card.IsPreviousPosition(Card c, int pos)
Check whether the c position before the change is represented by pos
●bool Card.IsControler(Card c, int controler)
Check whether the current control of c is a controler
●bool Card.IsPreviousControler(Card c, int controler)
●bool Card.IsOnField(Card c)
Check if c is present
Note: This function returns false when the monster summons, reverses the call, and when the summon is successful
●bool Card.IsLocation(Card c, int location)
Check if c is the current location
Note: When the monster summon, reverse call, call special summon before the success,
And location = LOCATION_MZONE, this function returns false
●bool Card.IsPreviousLocation(Card c, int location)
Check if the location before c is location
●bool Card.IsLevelBelow(Card c, int level)
Check whether c is below the level level (at least 1)
●bool Card.IsLevelAbove(Card c, int level)
Check whether c is above level level
●bool Card.IsRankBelow(Card c, int rank)
Check whether c is below the rank rank (at least 1)
●bool Card.IsRankAbove(Card c, int rank)
Check whether c is above the class rank
●bool Card.IsLinkBelow(Card c, int link)

●bool Card.IsLinkAbove(Card c, int link)

●bool Card.IsAttackBelow(Card c, int atk)
Check whether c is attack power atk below (at least 0)
●bool Card.IsAttackAbove(Card c, int atk)
Check whether c is more than attack power atk
●bool Card.IsDefenseBelow(Card c, int def)
Check whether c is defensive def below (at least 0)
●bool Card.IsDefenseAbove(Card c, int def)
Check c is defensive def above
●bool Card.IsPublic(Card c)
Check if c is open
●bool Card.IsForbidden(Card c)
Check whether c is in the declaration prohibition state
●bool Card.IsAbleToChangeControler(Card c)
Check whether c can change the control
Note: This function returns false only if the card receives the effect of "Can not change control"
●bool Card.IsControlerCanBeChanged(Card c[, bool ignore_mzone = false, int zone = 0xff])
Check whether the control of c can be changed
Note: This function appends the space on the field to the Card.IsAbleToChangeControler
●bool Card.IsCanHaveCounter(Card c,int countertype)

●bool Card.AddCounter(Card c, int countertype, int count[, int singly = false])
Place count count counter type c for c, singly true to add one to the upper limit
●void Card.RemoveCounter(Card c, int player, int countertype, int count, int reason)
Let the player player remove count counters of type c on c with reason
●int Card.GetCounter(Card c, int countertype)
Returns the number of countertype types on c
●void Card.EnableCounterPermit(Card c, int countertype[, int location])
Allow c [to be placed in the location location] that can be placed "can be placed on the counter countertype
The default value of location depends on the type of c, and the monster needs to specify whether it can place a pointer in a monster or pendulum area
●void Card.SetCounterLimit(Card c, int countertype, int count)
Set c to place the upper limit of countertype type counters
●bool Card.IsCanChangePosition(Card c)

●bool Card.IsCanTurnSet(Card c)
Check whether c can turn into the inside of that
●bool Card.IsCanAddCounter(Card c, int countertype, int count[, int singly = false, int location])
Check if c can place count counters of type countertype [singly = true]
●bool Card.IsCanRemoveCounter(Card c, int player, int countertype, int count, int reason)
Check if the player player can remove count counters of type c on c for reason
●bool Card.IsCanBeFusionMaterial(Card c[, Card fc])
Check whether c can become a [fusion monster fc] fusion material, ignore_mon = true does not check whether c is a monster
●bool Card.IsCanBeSynchroMaterial(Card c[, Card sc, Card tuner])
Check whether c can become a homophonic homophonic monster sc material
●bool Card.IsCanBeRitualMaterial(Card c, Card sc|nil)
Check whether c can serve as ritual monsters sc sacrifice
●bool Card.IsCanBeXyzMaterial(Card c, Card sc|nil)
Check whether c can become an excessive monster sc excess material
●bool Card.IsCanBeLinkMaterial(Card c, Card sc|nil)

●bool Card.CheckFusionMaterial(Card c[, Group g|nil, Card gc|nil, int chkf = PLAYER_NONE])
Check if g contains a set of fusion material that c needs [must contain gc]
## Check the Condition function for the effect of EFFECT_FUSION_MATERIAL according to the type of c
●bool Card.CheckFusionSubstitute(Card c, Card fc)
Check whether the c can replace the material description card name of the fusion monster fc
●bool Card.IsImmuneToEffect(Card c, Effect e)
Check whether c immune effect e (that is not affected by the impact of e)
●bool Card.IsCanBeEffectTarget(Card c[, Effect e])
Check whether c can be the object of effect e
●bool Card.IsCanBeBattleTarget(Card c1, Card c2)
Check whether c1 can become a target of c2
●void Card.AddMonsterAttribute(Card c, int type[, int attribute, int race, int level, int atk, int def])
Add the monster value to the trap card
Note: Values ​​recorded in the database are treated as the original value, and are set to zero here
●void Card.TrapMonsterComplete(Card c, int extra_type)
So trap the trap monster c to occupy a magic trap grid, and add the extra_type monster type
Note: The Trap Monster attribute refers to both the monster and the trap at the same time, and an extra trap that makes a magic trap can not be used
●void Card.CancelToGrave(Card c[, bool cancel = true])
Cancel to send to determine the state tomb, cancel = false to reset the tomb to determine the state
Note: to send the tomb to determine the state refers to the field to start without leaving field magic and traps, the state of these cards
Cards sent to the tomb determine the state can not return cards and cards, and sent to the cemetery at the end of the chain
The purpose of this function is to cancel this state to stay in the field, for the light of the sword and seal the Scarlet Scarlet card
●int,int Card.GetTributeRequirement(Card c)
Returns the minimum and maximum number of sacrifices required to normally call c
●Card Card.GetBattleTarget(Card c)
Returns the card that fought with c
●Group,bool Card.GetAttackableTarget(Card c)
Returns the attackable card set and whether it can attack directly
●void Card.SetHint(Card c, int type, int value)
Set the card prompt for type c to c
Type can only be the following value, the corresponding value type is
CHINT_TURN Turns
CHINT_CARD card id
CHINT_RACE race
CHINT_ATTRIBUTE property
CHINT_NUMBER number
CHINT_DESC Description
●void Card.ReverseInDeck(Card c)
The setting c is indicated in the front of the deck
●void Card.SetUniqueOnField(Card c, int s, int o, function|int unique_code[, int unique_location = LOCATIOIN_ONFIELD])
Set c to unique_code only in the field [or monster area or magic trap area, determined by the unique_location] can only exist one
S is not 0 will check the uniqueness of their field, o is not 0 check the other field uniqueness
●bool Card.CheckUniqueOnField(Card c, int check_player[, int check_location = LOCATION_ONFIELD, Card icard|nil])
Check the uniqueness of c in the check_player field
●void Card.ResetNegateEffect(Card c[, int code1,...])
Reset c affected by the effect of cards whose card number is code1, code2 ...
●void Card.AssumeProperty(Card c, int assume_type, int assume_value)
Use the value of assume_type c as assume_value (genome fighter)
Assume_type is the following type
ASSUME_CODE card number
The ASSUME_TYPE type
ASSUME_LEVEL class
ASSUME_RANK class
ASSUME_ATTRIBUTE property
ASSUME_RACE race
ASSUME_ATTACK Attack power
ASSUME_DEFENSE Defense
●void Card.SetSPSummonOnce(Card c, int spsummon_code)
Set c can only be a round of a special call (they reveal, wave dragon)
The same spsummon_code shares 1 number of times
●bool Card.IsRitualType(Card c)

●bool Card.SetEntityCode(Card c, int code[, bool no_alias = false])

●void Card.SetCardData(Card c, int type, int value)

●int Card.GetLinkMarker(Card c)

●int Card.GetOriginalLinkMarker(Card c)

●bool Card.IsXyzSummonableByRose(Card c, Card c1, Card c2)

●int Card.GetRemovedOverlayCount(Card c)

●bool Card.IsOriginalCodeRule(Card c，int code)

●bool Card.IsLinkSummonable(Card c, Group mg|nil[, min = 0, max = 0])

●bool Card.IsCanOverlay(Card c)

========== Effect ==========
●Effect Effect.CreateEffect(Card c)
Create a new empty effect
And the owner of the effect is c
●Effect Effect.GlobalEffect()
Create a new global effect
●Effect Effect.Clone(Effect e)
Create a new copy of effect e
●void Effect.Reset(Effect e)
The effect of e reset, reset can not be used after this effect
●int Effect.GetFieldID(Effect e)
Gets the id of the effect e
●void Effect.SetDescription(Effect e, int desc)
Sets the effect description for effect e
●void Effect.SetCategory(Effect e, int cate)
Set the Category property
●void Effect.SetType(Effect e, int type)
Set the Type property for effect e
●void Effect.SetCode(Effect e, int code)
Set the Code property for effect e
●void Effect.SetProperty(Effect e, int prop1[, int prop2])
Set the Property property
●void Effect.SetRange(Effect e, int range)
Set the Range property for effect e
●void Effect.SetAbsoluteRange(Effect e, int playerid, int s_range, int o_range)
Set the target range property and set the EFFECT_FLAG_ABSOLUTE_RANGE flag
Playerid! = 0 s_range and o_range invert
●void Effect.SetCountLimit(Effect e, int count = 1[, int code = 0])
Set the number of times a round can be launched count (only trigger type effect is valid), the same code (not equal to 0 or 1) share a number of times
The code contains the following values ​​that have special properties
EFFECT_COUNT_CODE_OATH The number of vows
EFFECT_COUNT_CODE_DUEL The number of times in the duel
EFFECT_COUNT_CODE_SINGLE the same card more than the number of public use of the effect (not the same name card)
●void Effect.SetReset(Effect e, int reset_flag[, int reset_count = 1])
Set the reset parameter
●void Effect.SetLabel(Effect e, int label)
Sets the Label property
●void Effect.SetLabelObject(Effect e, Card|Group|Effect labelobject)
Sets the LabelObject property
●void Effect.SetHintTiming(Effect e, int s_time[, int o_time = s_time])
Set the prompt point
●void Effect.SetCondition(Effect e, function con_func)
Set the Condition property
●void Effect.SetCost(Effect e, function cost_func)
Set the Cost property
●void Effect.SetTarget(Effect e, function targ_func)
Set the Target property
●void Effect.SetTargetRange(Effect e, int s_range, int o_range)
Set the Target Range property for effect e
S_range refers to our area of ​​influence
The o_range value affects the partner area
If the EFFECT_FLAG_ABSOLUTE_RANGE flag is specified in the property property,
Then s_range refers to the player 1 affected area, o_range refers to player 2 affected area
If this is a call (cover) / limit call (cover) / special call procedure
(EFFECT_SUMMON_PROC / EFFECT_LIMIT_SUMMON_PROC / EFFECT_SPSUMMON_PROC, etc.)
And the property specifies the EFFECT_FLAG_SPSUM_PARAM flag,
Then s_range that special summoned to the players of the venue,
O_range represents a selectable representation
●void Effect.SetValue(Effect e, function|int|bool val)
Set the Value property
●void Effect.SetOperation(Effect e, nil|function op_func)
Set the Operation property
●void Effect.SetOwnerPlayer(Effect e[, int player = 0])
Set the OwnerPlayer property to player
●int Effect.GetDescription(Effect e)
Returns the description of the effect
●int Effect.GetCode(Effect e)
Returns the code property
●int Effect.GetType(Effect e)
Returns the Type property
●int,int Effect.GetProperty(Effect e)
Returns the Property property
●int Effect.GetLabel(Effect e)
Returns the Label property
●Card|Group|Effect Effect.GetLabelObject(Effect e)
Returns the LabelObject property
●int Effect.GetCategory(Effect e)
Returns the Category property
●Card Effect.GetOwner(Effect e)
Returns the Owner property
●Card Effect.GetHandler(Effect e)
Returns the card on which the effect takes effect (usually a card that registers the effect with Card.RegisterEffect)
●function Effect.GetCondition(Effect e)
Returns the condition property
●function Effect.GetTarget(Effect e)
Returns the target attribute
●function Effect.GetCost(Effect e)
Returns the cost attribute
●function|int Effect.GetValue(Effect e)
Returns the value attribute
●function Effect.GetOperation(Effect e)
Returns the operation attribute
●int Effect.GetActiveType(Effect e)
Returns the effect type of e (monster, magic, trap)
And launch the effect of the type of card is not necessarily the same, such as the spirit of pendulum effect as a magic card effect
●bool Effect.IsActiveType(Effect e, int type)
Check if the effect type of e (monster, magic, trap) has a type
●int Effect.GetOwnerPlayer(Effect e)
Returns the OwnerPlayer property, which is typically the controller of the Owner
●int Effect.GetHandlerPlayer(Effect e)
Return to the current, usually Handle controller
●bool Effect.IsHasProperty(Effect e, int prop1[, int prop2])
Check if the effect contains the flags prop1 [and prop2]
●bool Effect.IsHasCategory(Effect e, int cate)
Check whether the effect contains cate
●bool Effect.IsHasType(Effect e, int type)
Check if the effect is of type type
●bool Effect.IsActivatable(Effect e, int player[, bool neglect_loc = false, bool neglect_target = false])
Check whether the effect can be launched by the player
●bool Effect.IsActivated(Effect e)
Check the effect of e is the effect of starting (chassis)
●int Effect.GetActivateLocation(Effect e)
Returns the firing area of ​​the effect e
●int Effect.GetActivateSequence(Effect e)

●bool Effect.CheckCountLimit(Effect e, int p)

●void Effect.UseCountLimit(Effect e, int p[, int count = 1, bool oath_only = false])

●void Effect.SetOwner(Effect e, Card c)

●int Effect.GetRange(Effect e)

●int[,int] Effect.GetCountLimit(Effect e)

========== Group ==========
●Group Group.CreateGroup()
Create a new empty deck
●void Group.KeepAlive(Group g)
Let the deck continue, set the deck to effect LabelObject needs to be set
●void Group.DeleteGroup(Group g)
Delete the card group g
●Group Group.Clone(Group g)
Create a new copy of card group g
●Group Group.FromCards(...)
Indefinite parameters, the incoming card into a combination of all cards and return
●void Group.Clear(Group g)
Empty the deck
●void Group.AddCard(Group g, Card c)
Increase g to g
●void Group.RemoveCard(Group g, Card c)
Remove c from g
●Card Group.GetFirst(Group g)
Returns the first card in g and resets the current pointer to the first card in g
Returns nil if card does not exist in g
●Card Group.GetNext(Group g)
Point the pointer to the next card and return the card, or nil if it does not exist
●int Group.GetCount(Group g)
Returns the number of cards in g
●int Group.__len(Group g)

●void Group.ForEach(Group g, function f,...)
Call f once for each card in g as a parameter
●Group Group.Filter(Group g, function f, Card|Group ex|nil,...)
The filter function filters the card from g that satisfies the filter condition f and is not equal to ex
Starting from the 4th parameter as an additional parameter
●int Group.FilterCount(Group g, function f, Card|Group ex|nil,...)
Filter function, and Group.Filter is basically the same, the difference is that this function only returns the number of cards to meet the conditions
●Group Group.FilterSelect(Group g, int player, function f, int min, int max, Card|Group ex|nil,...)
Filter function, allowing players to choose from the g player min-max sheets meet the screening conditions f and not equal to the ex card
Starting with the 7th argument is an additional parameter
●Group Group.Select(Group g, int player, int min, int max, Card|Group ex|nil)
Let player player from g select the min-max Zhang is not equal to the ex card
●Card Group.SelectUnselect(Group g1, Group g2|nil, int playerid[, bool finish, bool cancel, int min = 1, int max = 1])

●Group Group.RandomSelect(Group g, int player, int count)
Let the player player randomly select count cards from g
Because it is a random choice, so the basic parameter useless player, randomly selected by the system
●bool Group.IsExists(Group g, function f, int count, Card|Group ex|nil,...)
Filter function to check if there is at least count of cards in g that satisfy the filter condition f and not equal to ex
Starting from the 5th parameter as an additional parameter
●bool Group.CheckWithSumEqual(Group g, function f, int sum, int min = 0, int max,...)
The subset summation decision function, f, is a function that returns an interger value
Check whether there is a subset of min-max in g that satisfies that the sum of the values ​​of each element of the subset f is equal to sum, starting at the 6th argument as an extra parameter
For example: g: CheckWithSumEqual (Card.GetSynchroLevel, 7,2,99)
Check if the sum of the same call levels in a subset of g satisfies a subset equal to 7
●Group Group.SelectWithSumEqual(Group g, int player, function f, int sum, int min, int max,...)
Let the player player select a subset of min-max from g so that the sum of the specific functions of the subset is equal to sum, starting at the 7th argument as an extra parameter
●bool Group.CheckWithSumGreater(Group g, function f, int sum,...)
The sum of the subsets is determined by a function f, which is a function that returns an interger value
Check that there is a subset in g that satisfies that the sum of the values ​​of each element of the subset f is just greater than or equal to sum, starting at the fourth argument as an extra parameter
For example: g: CheckWithSumGreater (Card.GetRitualLevel, 8)
Check if the sum of the ritual classes in g satisfies a subset of 8 or greater
Note: The decision must be "just" greater than or equal to
To grade, for example, to make the total level is greater than or equal to 8, you can choose LV1 + LV7 and can not choose LV1 + LV4 + LV4
●Group Group.SelectWithSumGreater(Group g, int player, function f, int sum,...)
Let the player player select a subset from g so that the sum of the particular function f of the subset is greater than or equal to sum, starting at the fifth argument as an extra parameter
●Group,int Group.GetMinGroup(Group g, function f,...)
F is a function that returns an interger value, and the card with the smallest value of f is selected from g
The second return value is the minimum value, starting at the third parameter as an additional parameter
To use the second return value Note Check g is not empty
●Group,int Group.GetMaxGroup(Group g, function f,...)
F is the function that returns an interger value, and the card with the largest value of f is selected from g
The second return value is the maximum value, starting with the third parameter as an additional parameter
To use the second return value Note Check g is not empty
●int Group.GetSum(Group g, function f,...)
Calculates the sum of the values ​​of all cards in g, f is the value function for each card, starting with the third parameter as an additional parameter
●int Group.GetClassCount(Group g, function f,...)
Calculate the number of all cards in g, f is the basis of the classification, return the same value as the same category, starting from the first three parameters for additional parameters
●void Group.Remove(Group g, function f, Card ex|nil,...)
Remove all cards from g that satisfy the filter condition f and not equal to ex, the fourth parameter starts with the extra argument
●void Group.Merge(Group g1, Group g2)
Combine all cards in g2 to g1
Note: g2 itself does not change
●void Group.Sub(Group g1, Group g2)
Remove the card from g1 that belongs to g2
Note: g2 itself does not change
●bool Group.Equal(Group g1, Group g2)
It is judged whether or not g1 and g2 are the same
●bool Group.IsContains(Group g, Card c)
Check g for card c
●Card Group.SearchCard(Group g, function f,...)
Returns the first card in g that satisfies the filter condition f, starting at the third argument as an extra argument
●int Group.GetBinClassCount(Group g, function f,...)

●Group Group.__add(Group|Card target1, Group|Card target2)

●Group Group.__bor(Group|Card target1, Group|Card target2)

●Group Group.__sub(Group|Card target1, Group|Card target2)

●Group Group.__band(Group|Card target1, Group|Card target2)

●Group Group.__bxor(Group|Card target1, Group|Card target2)

========== Duel ==========
●void Duel.EnableGlobalFlag(int global_flag)
Set the global flag global_flag
●int Duel.GetLP(int player)
Returns the current LP of the player's player
●void Duel.SetLP(int player, int lp)
Set the player's current LP to lp
●int Duel.GetTurnPlayer()
Returns the current round of players
●int Duel.GetTurnCount([int player])
Returns the current number of turns
●int Duel.GetDrawCount(int player)
Returns the player's number of rules drawn per turn
●void Duel.RegisterEffect(Effect e, int player)
Register the effect e as the player's effect to the global environment
●Effect Duel.RegisterFlagEffect(int player, int code, int reset_flag, int property, int reset_count = 1[, int label])
For the player to register the global environment logo effect
This effect always affects the player's (EFFECT_FLAG_PLAYER_TARGET) and will not be invalidated
The rest is the same as Card.RegisterFlagEffect
●int Duel.GetFlagEffect(int player, int code)
Returns the number of specific marker effects for the player's player
●void Duel.ResetFlagEffect(int player, int code)
Manually reset the player player's specific logo effect
●void Duel.ResetTimeLimit(int player[, int time = 0])

●void Duel.SetSummonCancelable(bool enabled)

●bool Duel.SetFlagEffectLabel(int player, int code, int label)

●int Duel.GetFlagEffectLabel(int player, int code)

●int Duel.Destroy(Card|Group targets, int reason[, int dest = LOCATION_GRAVE])
Destroy targets dest by reason reason, the return value is actually destroyed by the number
If the reason contains REASON_RULE, the break event will not check whether the card is immune,
Does not trigger the generation of breaking effect and ignore the "can not destroy"
●int Duel.Remove(Card|Group targets, int pos, int reason)
In the case of reason, except for the pos form, the return value is the actual number being manipulated
If the reason contains REASON_TEMPORARY, then the exception is considered temporary, you can return to the field by Duel.ReturnToField
●int Duel.SendtoGrave(Card|Group targets, int reason)
The reason for the targets to the cemetery, the return value is the actual number of operations
●int Duel.SendtoHand(Card|Group targets, int player|nil, int reason)
The reason to target the player sent to the player's hand, the return value is the actual number of operations
If player is nil, the card's holder's hand is returned
●int Duel.SendtoDeck(Card|Group targets, int player|nil, int seq, int reason)
The reason for the targets sent to the players player card group, the return value is the actual number of operations
If player is nil, the card holder of the card is returned
If seq = 0, it is the top of the returned card group; seq = 1 is the bottom of the returned card group;
The rest of the case is to return to the top and mark the need to wash the card group
●int Duel.SendtoExtraP(Card|Group targets, int player|nil, int reason)
The reason for the reason the spirit of the swing card targets sent to the player player extra card group, the return value is the actual number of operations
If player is nil, it returns the extra card group for the card holder
●Group Duel.GetOperatedGroup()
This function returns a card set that was actually manipulated before a card operation
Duel.Destroy, Duel.Remove, Duel.SendtoGrave,
Duel.SendtoHand, Duel.SendtoDeck, Duel.SendtoExtraP, Duel.Release,
Duel.ChangePosition, Duel.SpecialSummon, Duel.DiscardDeck
●void Duel.Summon(int player, Card c, bool ignore_count, Effect e|nil[, int min = 0, int zone = 0x1f])
Let the player to the effect of e to c is usually called (not set), at least use min sacrifice
If e = nil, then in accordance with the general rules of the general call usually call
If ignore_count = true, the usual number of calls per turn limit is ignored
●void Duel.SpecialSummonRule(int player, Card c[, int sumtype = 0])
Let player player on c special summon procedures
●void Duel.SynchroSummon(int player, Card c, Card tuner|nil[, Group mg|nil])
Let the player player to tuner as the adjustment [mg for the material] on the c cohomology summon procedures
●void Duel.XyzSummon(int player, Card c, Group mg|nil[, min = 0, max = 0])
Let the player player [from the mg] [choose min-max a material] on the c to call the excess procedure
Mg is not empty and min is 0 mg directly to all the excess material
●void Duel.LinkSummon(int player, Card c, Group mg|nil[, Card gc, int minc, int maxc])

●void Duel.MSet(int player, Card c, bool ignore_count, Effect e|nil[, min = 0, int zone = 0x1f])
Let the player to the effect of c is usually called Set, at least use min sacrifice
If e = nil, then in accordance with the general rules of the general call usually call
If ignore_count = true, the usual number of calls per turn limit is ignored
●void|int Duel.SSet(int player, Card|Group targets[, int target_player = player, bool confirm = true])
Let the player player place the targets into the target trap's magic trap
If targets is Group, the number of successful operations is returned
●bool|Card Duel.CreateToken(int player, int code)
Creates a new Token with the passed in parameter value and returns
●int Duel.SpecialSummon(Card|Group targets, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos[, int zone = 0xff])
Let player player to sumtype way, pos that special targets to target_player target field
If nocheck is true, the card's calling condition is disregarded. If nolimit is true,
The return value is the number of cards that were successfully summoned
●bool Duel.SpecialSummonStep(Card c, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos[, int zone = 0xff])
This function is Duel.SpecialSummon decomposition process, only a special summon a card c
This function is used for an effect while simultaneously calling multiple cards with different parameters
This function must be used with Duel.SpecialSummonComplete
The return value indicates whether or not the special call succeeded
●void|int Duel.SpecialSummonComplete()
This function is called after determining that a number of calls to Duel.SpecialSummonStep are completed, for triggering an event
●bool Duel.IsCanAddCounter(int player, int countertype, int count, Card c)
Check if the player can add count counterstype to card c
●bool Duel.RemoveCounter(int player, int s, int o, int countertype, int count, int reason)
Causes the player player to remove count objects of the countertype type present on the farm for reason reasons. The return value indicates success
S represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player
●bool Duel.IsCanRemoveCounter(int player, int s, int o, int countertype, int count, int reason)
Checks whether the player player can remove count objects of the countertype type on the farm for reason reasons
S represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player
●int Duel.GetCounter(int player, int s, int o, int countertype)
Returns the number of counterstype types that exist on the farm
S represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player
●int Duel.ChangePosition(Card|Group targets, int au[, int ad = au, int du = au, int dd = au, bool noflip = false, bool setavailable = false])
Changing the representation of targets returns the number of actual operations
The attack on the watch side becomes au, the attack on the inside indicates ad,
The side of the garage that becomes du, inside the garrison said to become dd
If noflip = true, the reverse effect will not be triggered (but the effect of inversion will be triggered)
If setavailable = true then the object will become the back side also launched reversal effect
●int Duel.Release(Card|Group targets, int reason)
The reason for the liberation of targets to return the value of the actual liberation of the number of targets
If the reason contains REASON_COST, it will not check whether the card is not affected by the effect
●bool Duel.MoveToField(Card c, int move_player, int target_player, int dest, int pos, bool enable)
Let the player move_player to move the c target_player field, the return value that is successful
Dest can only be LOCATION_MZONE or LOCATION_SZONE, pos represents an optional representation, and enable indicates whether or not the effect of c is applied immediately
●bool Duel.ReturnToField(Card c[, int pos, int zone = 0xff])
To return the form c to the field pos, pos default value is the expression before leaving the field, the return value indicates whether the success
C must be a REASON_TEMPORARY reason to leave, and leave the position did not leave that position
●void Duel.MoveSequence(Card c, int seq)
Move the serial number of c, usually used to change the grid in the field or in the card group to move to the top or bottom
●void Duel.SwapSequence(Card c1, Card c2)

●void Duel.Activate(Effect e)

●void Duel.SetChainLimit(function f)
Set the chain conditions, f function prototype for bool f (e, ep, tp)
E said to limit the effect of chain, ep said to limit the chain of players, tp that launched the effect of the players
Calling this function in cost or target processing can limit the kinds of effects that can be chained (such as superfusion)
If f returns false, it means that the chain can not be chained. Once the chain condition has been set, the new chain will be canceled.
●void Duel.SetChainLimitTillChainEnd(function f)
●function with Duel.SetChainLimit, but this function sets the chain until the end of the chain will be lifted
●Effect Duel.GetChainMaterial(int player)
Returns the effect of the chained material that is played by the player. This function is only used to blend the effect of a class card
●void Duel.ConfirmDecktop(int player, int count)
Confirm the player card group above count cards
●void Duel.ConfirmExtratop(int player, int count)

●void Duel.ConfirmCards(int player, Card|Group targets)
Identify targets for the player
●void Duel.SortDecktop(int sort_player, int target_player, int count)
Let the player sort_player on the player target_player card group at the top count card sort
●bool[,Group,int,int,Effect,int,int] Duel.CheckEvent(int event[, bool get_info])
Check whether the current event point
If get_info = true and is the correct time point also returns the trigger point information eg, ep, ev, re, r, rp
●void Duel.RaiseEvent(Group|Card eg, int code, Effect re, int r, int rp, int ep, int ev)
To eg, ep, ev, re, r, rp trigger a point in time
●void Duel.RaiseSingleEvent(Card eg, int code, Effect re, int r, int rp, int ep, int ev)
To eg, ep, ev, re, r, rp for the card ec trigger a single point in time
●bool Duel.CheckTiming(int timing)
Check whether the current prompt is the timing point
●int,int Duel.GetEnvironment()
Returns the two values ​​that represent the current venue code, as well as the source of the current venue effect
The site code refers to the code of the venue card in effect, or the value of the effect of the venue change
Source Player is the controller of the card in effect, or the controller of the Poseidon Witch, etc.
●bool Duel.IsEnvironment(int code[, int player = PLAYER_ALL, int loc = LOCATION_FZONE + LOCATION_ONFIELD])
Check whether the player player is the source code of the venue code
The site code refers to the code of the venue card in effect, or the value of the effect of the venue change
Source Player is the controller of the card in effect, or the controller of the Poseidon Witch, etc.
●void Duel.Win(int player, int win_reason)
The current effect is dealt with so players win_reason duel victory
●int Duel.Draw(int player, int count, int reason)
Let the player play the count card with the reason, and return the number of cards actually drawn
If the reason contains REASON_RULE the draw is not affected by the "can not draw" effect
●int Duel.Damage(int player, int value, int reason[, bool is_step = false])
To the reason reason to give players the player caused value damage, the actual value of the damage received
The return value is 0 if the damage becomes an effect such as a reply.
Is_step to true is the damage / recovery LP process decomposition, need to call Duel.RDComplete() trigger point
●int Duel.Recover(int player, int value, int reason[, bool is_step = false])
To reason reason players to player value LP, return to the actual response value
The return value is 0 if it is affected by an effect such as a return to harm.
Is_step to true is the damage / recovery LP process decomposition, need to call Duel.RDComplete() trigger point
●void Duel.RDComplete()
In the call Duel.Damage / Duel.Recover, if is_step parameter is true, you need to call this function when the trigger point
●bool Duel.Equip(int player, Card c1, Card c2[, bool up = true, bool is_step = false])
The player as a player c1 equipment card equipment to the c2, the return value that is successful
Up = false to retain the card before the representation
Is_step = true is the decomposition of the equipment process, the need to cooperate with Duel.EquipComplete use
●void Duel.EquipComplete()
In the call Duel.Equip, if is_step parameter is true, you need to call this function when the trigger point
●bool Duel.GetControl(Card|Group targets, int player[, int reset_phase = 0, int reset_count = 0, int zone = 0xff])
Let players get control of the player, the return value indicates success
●bool Duel.SwapControl(Card|Group targets1, Card|Group targets2[, int reset_phase = 0, int reset_count = 0])
Exchange c1 and c2 control, the return value that is successful
●bool Duel.CheckLPCost(int player, int cost)
Check player player can pay cost point lp
●void Duel.PayLPCost(int player, int cost)
Allow players to pay cost point player lp
●int Duel.DiscardDeck(int player, int count, int reason)
To reason player player card group top count cards sent to the cemetery, the actual transfer of the number
●int Duel.DiscardHand(int player, function f, int min, int max, int reason, Card|Group ex|nil,...)
Filter function allows the player to select and discard the player to meet the screening conditions f soldiers is not equal to ex min-max Zhang card
The seventh argument starts as an extra parameter
●void Duel.DisableShuffleCheck([bool disable = true])
So that the next operation does not check for the need for a wash card set or a hand card
Note: If you do not call this function,
In addition to calling Duel.DiscardDeck and Duel.Draw remove the card from the card group or add the card to the card
Or the card is added to the deck (not the top or bottom), the system automatically cleans the card group or the hand card at the end of the effect process
If you do not want to do so, for example, from the top of the card group, except for a card and other operations, you need to call this function
This function only ensures that no subsequent scrub detection is performed in the next operation
●void Duel.DisableSelfDestroyCheck([bool disable = true])

●void Duel.ShuffleDeck(int player)
Manually cleans the player group
NOTE: The status of the wash detection is reset
●void Duel.ShuffleExtra(int player)

●void Duel.ShuffleHand(int player)
Manual wash player player's hand card
NOTE: The status of the wash detection is reset
●void Duel.ShuffleSetCard(Group g)
Cut the card (magic hat) over the monster area
●void Duel.ChangeAttacker(Card c[, bool ignore_count = false])
Will attack the monster into c
Note: This function will make the original attack monster attack
# ●void Duel.ReplaceAttacker(Card c)
# Use c to replace the currently attacked card for the damage phase
●bool Duel.ChangeAttackTarget(Card c|nil)
Will attack the object into c, c for nil that direct attack, the return value indicates whether the successful transfer of attack objects
●void Duel.CalculateDamage(Card c1, Card c2[, bool new_attack = false])
Let c1 and c2 combat damage calculation
●int Duel.GetBattleDamage(int player)
Returns the player's player's damage during this battle
●void Duel.ChangeBattleDamage(int player, int value[, bool check = true])
The player player in this battle by the harm into value, check for false is the original combat damage to 0 also change the damage
●void Duel.ChangeTargetCard(int chainc, Group g)
The chain chainc the object into g
●void Duel.ChangeTargetPlayer(int chainc, in player)
The chain chainc the object player into player
●void Duel.ChangeTargetParam(int chainc, int param)
The chain chainc parameters into param
●void Duel.BreakEffect()
Interrupt the current effect, so that after the effect of treatment as not treated simultaneously, this function will cause the wrong time
●void Duel.ChangeChainOperation(int chainc, function f)
The effect of the chain chainc processing function replaced by f, used to achieve "the effect becomes" effect
●bool Duel.NegateActivation(int chainc)
So that the chain chainc launch invalid, the return value that is successful
●bool Duel.NegateEffect(int chainc)
So that the chain chainc invalid effect, the return value that is successful
●void Duel.NegateRelatedChain(Card c, int reset)
So that card c has launched the chain are invalid, reset event occurs reset
●void Duel.NegateSummon(Card|Group targets)
So that the call is being summoned · reverse call special summoned targets invalid
●void Duel.IncreaseSummonedCount([Card c])
Manual consumption of 1 player [for card c] the number of the usual call
●bool Duel.CheckSummonedCount([Card c])
Check whether the round player can still summon this turn [Card c]
●int Duel.GetLocationCount(int player, int location[, int use_player, int reason = LOCATION_REASON_TOFIELD, int zon = xff])
Returns the number of spaces available in the player's field
Location can only be LOCATION_MZONE or LOCATION_SZONE
Reason is LOCATION_REASON_TOFIELD or LOCATION_REASON_CONTROL
# # Additional parameters related to the effect of Caesar fighting field
●int Duel.GetMZoneCount(int player[, Group|Card targets, int use_player, int reason = LOCATION_REASON_TOFIELD, int zone = 0xff])

●int Duel.GetLocationCountFromEx(int player[, int reason_player = player, Group|Card targets|nil, Card sc, int zone = 0xff])

●int Duel.GetUsableMZoneCount(int player[, int use_player])

●Group Duel.GetLinkedGroup(int player, int s_range, int o_range)

●int Duel.GetLinkedGroupCount(int player, int s_range, int o_range)

●int Duel.GetLinkedZone(int player)

●Card Duel.GetFieldCard(int player, int location, int seq)

Back to player The player's field is located in the location number seq card, commonly used to obtain the field area · Spirit pendulum area card
●bool Duel.CheckLocation(int player, int location, int seq)
Check if the player's player field is seq in the location of the space is available
●int Duel.GetCurrentChain()
Returns the chain number currently being processed
●... Duel.GetChainInfo(int chainc,...)
Returns the chainc information, if chainc = 0, returns the chain of information currently being processed
This function returns the corresponding number of return values ​​in sequence according to the number of arguments passed in. The arguments can be:
CHAININFO_CHAIN_COUNT The serial number of the chain
CHAININFO_TRIGGERING_EFFECT The effect of the chain
CHAININFO_TRIGGERING_PLAYER
CHAININFO_TRIGGERING_CONTROLER The player to which the chained position belongs
CHAININFO_TRIGGERING_LOCATION The location where the chain occurred
CHAININFO_TRIGGERING_SEQUENCE The number of the position where the chain occurred
CHAININFO_TARGET_CARDS Chain of object cards
CHAININFO_TARGET_PLAYER The target player for the chain
CHAININFO_TARGET_PARAM The object parameters of the chain
CHAININFO_DISABLE_REASON The chain is invalid for the effect of the effect
CHAININFO_DISABLE_PLAYER The chain is invalid for the reason the player
CHAININFO_CHAIN_ID The unique identifier for the chain
CHAININFO_TYPE Type of Chain Card (Monster, Magic, Trap)
CHAININFO_EXTTYPE The specific type of chain card (for example, monster, continuous magic, counterattack trap)
For example:
Duel.GetChainInfo(0, CHAININFO_TRIGGERING_LOCATION, CHAININFO_TARGET_CARDS)
This will return the location and object card where the current chain occurred
●Group,int,int,Effect,int,int Duel.GetChainEvent(int chainc)

●Card,... Duel.GetFirstTarget()
Returns all linked object cards that are normally only used when an object is used
●int Duel.GetCurrentPhase()
Returns the current stage
●void Duel.SkipPhase(int player, int phase, int reset_flag, int reset_count[, int value])
Skip player phase phase player, and in a specific stage after reset, reset parameters and the same effect
#value is only useful for phase = PHASE_BATTLE, value = 1 Skip the end of the combat phase, for "turn into the end of the round" (Lucky Elvis, Flash)
●bool Duel.IsDamageCalculated()
Used to check if damage has been calculated during the damage phase
●Card Duel.GetAttacker()
Return the card for this combat attack
●Card|nil Duel.GetAttackTarget()
Return to the battle was attacked card, if the return nil said that a direct attack
●Card|nil Duel.GetBattleMonster(int playerid)

●bool Duel.NegateAttack()
Invalid This attack, the return value indicates whether the success
This attack has been invalidated by other effects or cause the attack card can not attack is false
●void Duel.ChainAttack([Card c])
So that the attack card [or card c] can be carried out an attack (opening up, the queen of the Queen)
●void Duel.Readjust()
Refresh the card information on the field
Unspecified or unclear principle Do not use this function to avoid an infinite loop
●void Duel.AdjustInstantly([Card c])
Manually refreshing the card's inactive state on card [affected by card c]
●Group Duel.GetFieldGroup(int player, int s, int o)
Returns the card at the specified location
●int Duel.GetFieldGroupCount(int player, int s, int o)
Returns the number of cards in the specified location
●Group Duel.GetDecktopGroup(int player, int count)
Returns the count card at the top of the player's deck
●Group Duel.GetExtraTopGroup(int player, int count)

●Group Duel.GetMatchingGroup(function f|nil, int player, int s, int o, Card|Group ex|nil,...)
Filter function to return to the specified location to meet the filter condition f and not equal to the ex card
The sixth parameter starts as an extra parameter
●int Duel.GetMatchingGroupCount(function f|nil, int player, int s, int o, Card|Group ex|nil,...)
Filter function to return to the specified location to meet the filter condition f and not equal to the number of ex card
●Card Duel.GetFirstMatchingCard(function f|nil, int player, int s, int o, Card|Group ex|nil,...)
Filter function to return to the specified location to meet the filter condition f and not equal to the first card ex
The sixth parameter starts as an extra parameter
●bool Duel.IsExistingMatchingCard(function f|nil, int player, int s, int o, int count, Card|Group ex|nil,...)
Filter the function to check if there are at least count cards that satisfy the filter condition f and not equal to ex
The seventh argument starts as an extra parameter
●Group Duel.SelectMatchingCard(int sel_player, function f|nil, int player, int s, int o, int min, int max, Card|Group ex|nil,...)
Filter function, the player sel_player select the specified location to meet the filter condition f and not equal to the ex min-max card
The ninth parameter starts as an extra parameter
●Group Duel.GetReleaseGroup(int player[, bool use_hand = false])
Return to the player player can be liberated (non-superior summoned use) of the deck, use_hand is true, including the hand card
●integer Duel.GetReleaseGroupCount(int player[, bool use_hand = false])
Return player player can be liberated (non-superior summoned with) the number of cards, use_hand is true, including the hand card
●bool Duel.CheckReleaseGroup(int player, function f|nil, int count, Card|Group ex|nil,...)
Check if the player has at least count of cards that meet the filter condition f and are not equal to ex (non-superior summons)
The fifth parameter starts as an extra parameter
●Group Duel.SelectReleaseGroup(int sel_player, function f|nil, int min, int max, Card|Group ex|nil,...)
Filter function, allowing players to choose from the field min-max Zhang is not equal to ex to meet the conditions f can be liberated card (non-superior summon)
●bool Duel.CheckReleaseGroupEx(int player, function f|nil, int count, Card|Group ex|nil,...)
Check whether there are at least count cards that can satisfy the filter condition f and are not equal to ex. (For non-superior summoning)
●Group Duel.SelectReleaseGroupEx(int player, function f|nil, int min, int max, Card|Group ex|nil,...)
Filter function, allowing the player player from the field · hand card selection min-max Zhang does not equal ex to meet the conditions of f can be liberated card (non-superior call)
●Group Duel.GetTributeGroup(Card c)
Returns the deck of cards used for the normal summon c to be released (for higher-level summons)
●int Duel.GetTributeCount(Card c[, Group mg, bool ex = false])
Returns the number of sacrifices that are normally used to invoke c, where ex = true allows monsters on the other side of the field (the wing of the Sun God-Sphere)
This number does not necessarily equal the number of cards in the return value of Duel.GetTributeGroup
Because some cards can be used as two sacrifices
●bool Duel.CheckTribute(Card target, int min[, int max, Group mg|nil, int toplayer, int zone = 0x1f])
●Group Duel.SelectTribute(int player, Card c, int min, int max[, Group mg|nil, int toplayer = c:GetControler()|nil])
Let the player player [from the mg] choose the min-max sacrifices that are normally used to summon c, ex = true to allow the monster on the other side of the field (the wing of the Sun God-Sphere)
●int Duel.GetTargetCount(function f|nil, int player, int s, int o, Card|Group ex|nil,...)
Basic with Duel.GetMatchingGroupCount, the difference lies in the need to add to determine whether the card is currently being processed by the effect of the object
●bool Duel.IsExistingTarget(function f|nil, int player, int s, int o, int count, Card|Group ex|nil,...)
Filter function to check whether there is at least the specified number of positions to meet the filter conditions f and not equal ex
And can become a card of an object that is currently being processed
The seventh argument starts as an extra parameter
●Group Duel.SelectTarget(int sel_player, function f|nil, int player, int s, int o, int min, int max, Card|Group ex|nil,...)
Filter function, so that player sel_player select the specified location to meet the filter condition f and not equal ex
And can be the min-max card of the object that is currently processing the effect
The ninth parameter starts as an extra parameter
This function sets the currently locked object to the selected card at the same time
●Group Duel.SelectFusionMaterial(int player, Card c, Group g[, Card gc|nil, int chkf = PLAYER_NONE])
Let the player player from the g to select a group [must contain gc] fusion fusion monster c material
## Operation based on the effect of the c type of EFFECT_FUSION_MATERIAL
●void Duel.SetFusionMaterial(Group g)
Set g to be the fusion material you want to use
●void Duel.SetSynchroMaterial(Group g)
Set g to be the cohomology material you want to use
●Group Duel.SelectSynchroMaterial(int player, Card c, function f1|nil, function f2|nil, int min, int max[, Card smat|nil, Group mg|nil])
Let the player player [from mg] select a set of clips that are required for the cohomology c [must contain smat (if there is mg ~ = nil this parameter is ignored)] The number of min-max clips that satisfy the condition
F1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions
●bool Duel.CheckSynchroMaterial(Card c, function f1|nil, function f2|nil, int min, int max[, Card smat|nil, Group mg|nil])
Check [mg] whether there is a group [must include smat] meet the conditions of the min-max cards as cohort calls c material
F1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions
●Group Duel.SelectTunerMaterial(int player, Card c, Card tuner, function f1|nil, function f2|nil, int min, int max[, Group mg|nil])
Let the player [from the mg] select a set of clips of the min-max cards that are tuned to be used for co-ordination of the required conditions for c.
F1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions
●bool Duel.CheckTunerMaterial(Card c, Card tuner, function f1|nil, function f2|nil, int min, int max[, Group mg|nil])
Check to tuner as an adjustment [in the mg] whether there is a set of min-max card to meet the conditions as cohort call c material
F1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions
●Group Duel.GetRitualMaterial(int player)
Returns the player's deck of cards available for ritual summoning material
Including hands, the field can be the liberation of the ceremony and the cemetery and other magic people card
●Group Duel.GetRitualMaterialEx(int player)

●void Duel.ReleaseRitualMaterial(Group g)
Liberation ceremony with the material g, if the ceremony is the cemetery and other magic cards are excluded
●Group Duel.GetFusionMaterial(int player[, int location])

●bool Duel.IsSummonCancelable()

●void Duel.SetSelectedCard(Card|Group cards)
Set the card to the selected card for Group.SelectWithSumEqual or Group.SelectWithSumGreater,
●Group Duel.GrabSelectedCard()

●void Duel.SetTargetCard(Card|Group targets)
Sets the currently chained objects to targets
Note that here the object refers to the generalized object, including objects that do not take the effect that the object may have to deal with
●void Duel.ClearTargetCard()
The current processing of the chain of all the objects cleared
●void Duel.SetTargetPlayer(int player)
Set the player that is currently handling the chained object to player
●void Duel.SetTargetParam(integer)
●void Duel.SetTargetParam(inte param)
Sets the object parameters of the chain that is currently being processed into param
●void Duel.SetOperationInfo(int chainc, int category, Card|Group targets, int count, int target_player, int target_param)
Sets the operation information of the currently processed chain This operation information contains the effect classification determined in the effect processing to be processed
For example, stealth snipers need to set CATEGORY_DICE, but can not set CATEGORY_DESTROY, because not sure
For destructive effects, targets need to be set to launch the object may become the impact of chain card,
And sets count to the number of cards to be processed as determined at launch
For example, when the black hole launched, targets need to be set to all the monsters on the field, count to set the number of strange field
For CATEGORY_SPECIAL_SUMMON, CATEGORY_TOHAND, CATEGORY_TODECK, etc., which need to move the card position,
If the card to be processed is deterministic (such as fetching objects), set targets for these cards, count for the number,
If the card to be processed is uncertain (the effect can be determined when processing, is generally not take the effect of the object)
Set the targets to nil, count is expected to deal with the number of cards,
Target_player is expected to be handled by the holder of the card (not sure to 0)
Target_param is the location of the card expected to be processed
For example: SetOperationInfo (0, CATEGORY_TOHAND, nil, 1, tp, LOCATION_DECK)
Operational information is used to initiate detection of many effects, such as Stardust Dragon, Royal Valley
●bool[,Card|Group,int,int,int] Duel.GetOperationInfo(int chainc, int category)
Returns the operation information of the chained chainc category, with a return value of 5,
The first return value is false to indicate that the class does not exist
The last four return values ​​correspond to the last four parameters of Duel.SetOperationInfo: Card|Group targets, int count, int target_player, int target_param
●int Duel.GetOperationCount(int chainc)
Returns the number of operational classifications contained in chained chainc
●void Duel.ClearOperationInfo(int chainc)

●bool Duel.CheckXyzMaterial(Card c, function f|nil, int lv, int min, int max, Group mg|nil)
Check on the field or mg in the presence of excess call c excess with the level of lv min-max meet the conditions of the stack f material
●Group Duel.SelectXyzMaterial(int player, Card c, function f|nil, int lv, int min, int max[, Group mg|nil])
Let the player player for the excess monster c [from the mg] to select the excess with the level of lv for the min-max meet the conditions of the stack f material
●void Duel.Overlay(Card c, Card|Group ocard)
The ocard as a stack of cards stacked c
●Group Duel.GetOverlayGroup(int player, int s, int o)
Returns all stacked cards at a specified location
●int Duel.GetOverlayCount(int player, int s, int o)
Returns the number of all stacked cards in the specified location
●bool Duel.CheckRemoveOverlayCard(int player, int s, int o, int count, int reason)
Check if the player can remove at least count cards for the specified reason
●bool Duel.RemoveOverlayCard(int player, int s, int o, int min, int max, int reason)
Let the player remove the min-max overlay card at the specified location for the reason reason. The return value indicates success
●void Duel.Hint(int hint_type, int player, int desc)
Send hint_type to the player player type of message prompts, the contents of the prompt desc
#hint_type can only be of the following types:
#HINT_SELECTMSG will prompt the content into the cache, used to select the card prompts, such as Duel.SelectMatchingCard, etc.
# HINT_OPSELECTED to the player tips "the other selected: ...", often used to prompt the player to choose what effect the other
# HINT_CARD desc should be the card number at this time, manually display the animated card launched, often used to prompt not to chain processing
# HINT_RACE desc should be race at this time, to the player prompted "the other party declared: ..." race
# HINT_ATTRIB At this time desc should be attributes, to the player prompted "the other party declared: ..." attribute
# HINT_CODE desc should be the card number, to the player prompt "the other party declared: ..." card
# HINT_NUMBER At this point desc as a simple number, to the player prompted "the other selected: ..."
#HINT_MESSAGE A dialog box appears to display information
# HINT_EVENT will be prompted to write the contents of the cache for the time of the prompt information (prompting prompt real-time effects)
#HINT_EFFECT Same as HINT_CARD
●void Duel.HintSelection(Group g)
Manually displays the animated effect of the selected object for g and records that the card is selected as the object
●bool Duel.SelectEffectYesNo(int player, Card c[, int desc = 95])
Let players choose whether to launch the card player c effect
●bool Duel.SelectYesNo(int player, int desc)
Let player player select Yes or No
●int Duel.SelectOption(int player, int desc1,...)
Let the player select the option, starting with the second argument, where each parameter represents an option
Returns the serial number of the selected option (0-based)
●void Duel.SelectSequence()

●int Duel.SelectPosition(int player, Card c, int pos)
Let player player select the representation of c and return
●int Duel.SelectField(int player, int count, int s, int o, int filter)

●int Duel.SelectDisableField(int player, int count, int s, int o, int filter)
Let the player player select the specified position to meet the marker condition filter count of the available space, and return to select the location of the marker
Commonly used to select areas can not use or move the monster grid
## Position markers are defined as follows
## flag = 0;
## seq is the number of the grid selected in player p, position l
## for (int32 i = 0; i <count; ++ i) {
0: 16) + (l [i] == LOCATION_MZONE? 0: 8)) ## flag|= 1 << (seq [i] + (p [i] == player?
##}
●int Duel.AnnounceRace(int player, int count, int available)
Let the player player declare count races from the optional races
Available is the combined value of all the optional races
●int Duel.AnnounceAttribute(int player, int count, int available)
Let the player player declare count attributes from the optional attribute
Available is the combined value of all optional attributes
●int Duel.AnnounceLevel(int player[, int min = 1|nil, int max = 12|nil,...])
Let the player declare a level
●int Duel.AnnounceCard(int player[, type = TYPE_MONSTER + TYPE_SPELL + TYPE_TRAP])
Let players declare a player [type type] card code
●int Duel.AnnounceCardFilter(int player,...)

●int Duel.AnnounceType(int player[, int antype = 70|71|72])
Let the player player declare a card type
●int,int Duel.AnnounceNumber(int player, int number,...)
Let the player player declare a number
Starting with the second argument, each parameter represents a declarable number
The first return value is the number of declarations, and the second return value is the declaration number of the position in all options
●int Duel.AnnounceCoin(int player[, int antype = 60|61])
Let the player declare the positive and negative sides of the coin
●... Duel.TossCoin(int player, int count)
Let the player player cast count (<= 5) coins, the return value for the count results, 0 or 1.
●... Duel.TossDice(int player, int count1[, int count2 = 0])
Let the player to cast count1 dice[, 1-player to vote count2 dice] (count1 + count2 <= 5)
The return value is count1 + count2 results, 1-6
●int Duel.RockPaperScissors([bool repeat = true])
●int,int,int,int,int Duel.GetCoinResult()
Returns the result of the current coin
●int,int,int,int,int Duel.GetDiceResult()
Returns the result of the current dice
●void Duel.SetCoinResult(int res,...)
Forcibly modify the result of casting coins to res
This function is used in the persistent EVENT_TOSS_COIN event
●void Duel.SetDiceResult(int res,...)
Forcibly modify the result of casting dice to res
This function is used in the persistent EVENT_TOSS_DICE event
●Effect|nil,... Duel.IsPlayerAffectedByEffect(int player, int code)
Check if the player is affected by the effect of the code type, and return the effect if there is one
●bool Duel.IsPlayerCanDraw(int player[, int count = 0])
Check the player player can effect pumping [count Zhang] card
●bool Duel.IsPlayerCanDiscardDeck(int player, int count)
Check player player can put the card group top count cards sent to the cemetery
●bool Duel.IsPlayerCanDiscardDeckAsCost(int player, int count)
Check the player player can put the card group top count cards sent to the cemetery as cost
●bool Duel.IsPlayerCanSummon(int player[, int sumtype, Card c])
Check player player can usually call [c, to sumtype]
If optional parameters are required, they must all be used
Returns false only if the player receives an effect such as "can not summon a superordinate"
●bool Duel.IsPlayerCanMSet(int player[, int sumtype, Card pcard])

●bool Duel.IsPlayerCanSSet(int player[, Card pcard])

●bool Duel.IsPlayerCanSpecialSummon(int player[, int sumtype, int sumpos, int target_player, Card c])
Check player player can special summon [c to target_player field to sumtype summation, sumpos form]
If optional parameters are required, they must all be used
●bool Duel.IsPlayerCanFlipSummon(int player, Card c)
Check whether the player can reverse the call player c
●bool Duel.IsPlayerCanSpecialSummonMonster(int player, int code[, int setcode|nil, int type|nil, int atk|nil, int def|nil, int level|nil, int race|nil, int attribute|nil, int pos = POS_FACEUP, int target_player = player, int sumtype = 0])
Check player player can be pos to the form of special summon the parameters of the monster to the target_player field
This function is usually used to determine whether it is possible to trick token and trap monsters
●bool Duel.IsPlayerCanSpecialSummonCount(int player, int count)
Check whether the player player special call count times
●bool Duel.IsPlayerCanRelease(int player, Card c)
Check whether the player can liberate the player c
●bool Duel.IsPlayerCanRemove(int player, Card c)
Check whether the player player except c
●bool Duel.IsPlayerCanSendtoHand(int player, Card c)
Check whether the player can send c to hand
●bool Duel.IsPlayerCanSendtoGrave(int player, Card c)
Check whether the player can send c to the cemetery
●bool Duel.IsPlayerCanSendtoDeck(int player, Card c)
Check whether the player can send c to the card group
●bool Duel.IsPlayerCanAdditionalSummon(int player)

●bool Duel.IsChainNegatable(int chainc)
Check the chain chainc launch can be invalid
●bool Duel.IsChainDisablable(int chainc)
Check chainC effect can be invalid
●bool Duel.CheckChainTarget(int chainc, Card c)
Check whether c is the correct object for chained chainc effects
●bool Duel.CheckChainUniqueness()
Check the existence of the current chain of the same name card launch, true that no card with the same name
●int,... Duel.GetActivityCount(int player, int activity_type,...)
Returns the number of times the player performed the corresponding activity_type operation
The activity_type is of the following type
ACTIVITY_SUMMON call (not including the usual call placed)
ACTIVITY_NORMALSUMMON Usually called (including the usual call placed)
ACTIVITY_SPSUMMON Special call
ACTIVITY_FLIPSUMMON Reverse call
ACTIVITY_ATTACK attack
ACTIVITY_BATTLE_PHASE enters the combat phase
●bool Duel.CheckPhaseActivity()
Check the player at the current stage whether the operation (whether at the beginning of the stage, such as the Seven King of the sword)
●void Duel.AddCustomActivityCounter(int counter_id, int activity_type, function f)
Set the action type to activity_type, code counter_id counter, placed in the initial_effect function
F for the filter function, the card type parameters, the return value of false cards for the following types of operations, the counter increased by 1 (at present up to 1)
The activity_type is of the following type
ACTIVITY_SUMMON call (not including the usual call set)
ACTIVITY_NORMALSUMMON usually called (including the usual call set)
ACTIVITY_SPSUMMON Special call
ACTIVITY_FLIPSUMMON Reverse call
ACTIVITY_CHAIN ​​Activates the effect
●int Duel.GetCustomActivityCount(int counter_id, int player, int activity_type)
Counter number counter_id count, the number of players to return to the following (currently up to 1)
The activity_type is of the following type
ACTIVITY_SUMMON call (not including the usual call set)
ACTIVITY_NORMALSUMMON usually called (including the usual call set)
ACTIVITY_SPSUMMON Special call
ACTIVITY_FLIPSUMMON Reverse call
ACTIVITY_CHAIN ​​Activates the effect
●int Duel.GetBattledCount(int player)
Returns the number of times a player fought this turn
●bool Duel.IsAbleToEnterBP()
Check whether the player can enter the combat phase of the round
●void Duel.SwapDeckAndGrave(int player)
This world and the underworld reversal dedicated. The players player card group and the cemetery exchange
●void Duel.MajesticCopy(Card c1, Card c2)
Salvation Star Dragon dedicated. Copy the effect described in c2 to c1
Forced to launch the effect can choose whether to launch
●void Duel.AssumeReset()

●int Duel.GetMasterRule()

●int,int,.. Duel.ReadCard(int|Card target, int type, int type2,..)

●int Duel.Exile(Card|Group target, int reason)

●void Duel.DisableActionCheck(bool enabled)

●void Duel.DisableSelfDestroyCheck([bool enabled = true])

●void Duel.SetMetatable(Card|Group|Effect target, table mt)

●void Duel.MoveTurnCount()

●Group Duel.GetCardsInZone(int player, int zone)

●bool Duel.XyzSummonByRose(int player, Card xyzcard, Card c1, Card c2)

●void Duel.LoadScript(string filename)

●int Duel.SelectField(int player, int flag1, int flag2, int count)

●void Duel.LinkSummon(int player, Card pcard, Group mg|nil[, Card lcard, int minc, int maxc])

●Card Duel.GetBattleMonster(int player)

●bool Duel.IsSummonCancelable()

●Card|Group Duel.GrabSelectedCard()

●void Duel.ClearOperationInfo(int chainc)

●bool Duel.IsPlayerCanMSet(int player[, int sumtype, Card scard])

●bool Duel.IsPlayerCanSSet(int player[, Card scard])

●bool Duel.IsPlayerCanAdditionalSummon(int player)

========== aux ============
# # Only commonly used functions
●int aux.GetXyzNumber(Card|int v)

●int aux.Stringid(int code, int id)
Used to index the card number code for the card the first id (from 0) effect prompts
●Card aux.Next(Group g)

●void aux.BeginPuzzle()
Start the mess
# # This function registers three global effects:
At the end of the # # turn, the player's base points become 0
## Skip drawing phase and preparation phase
●bool aux.IsDualState(Effect e)
Check the double monster e: GetHandler () is re-call state
Commonly used in the double monster re-summoned to obtain the effect of e Condition attribute
●bool aux.IsNotDualState(Effect e)
Antisense of aux.IsDualState
●bool aux.DualNormalCondition(Effect e)
Check if the double monster e: GetHandler () is considered a normal monster state
●void aux.EnableDualAttribute(Card c)
Add double for the c monster attributes
●Effect,Effect aux.EnableNeosReturn(Card c[, function operation, int set_category])

●void aux.EnableSpiritReturn(Card c, int event1,...)

●bool aux.IsUnionState(Effect e)

●void aux.SetUnionState(Card c)

●bool aux.CheckUnionEquip(Card uc, Card tc)

●void aux.EnableUnionAttribute(Card c, function f)

●Effect aux.EnableChangeCode(Card c, int code[, int location, function condition])

●function aux.TargetEqualFunction(function f, any value,...)

●function aux.TargetBoolFunction(function f,...)

●function aux.FilterEqualFunction(function f, any value,...)

●function aux.FilterBoolFunction(function f,...)

●function aux.Tuner(function f|nil,...)

●function aux.NonTuner(function f|nil,...)

●Card|Group|Effect|int|bool|string|nil|function|table|any aux.GetValueType(any value)

●Group aux.GetMustMaterialGroup(int player, int code)

●bool aux.MustMaterialCheck(Card|Group value, int player, int code)

●bool aux.MustMaterialCounterFilter(Card c, Group g)

●void aux.AddSynchroProcedure(Card c, function f1|nil, function f2|nil, int minc[, int maxc = 99])
Add a cohomology call to c
F1 to adjust the filter to meet the conditions, f2 to adjust to meet other than the filter conditions (usually aux.NonTuner)
Adjust monsters other than ct at least
●void aux.AddSynchroProcedure2(Card c, function f1, function f2)
Add a cohomology call to c
F1 to adjust the filter to meet the conditions, f2 to adjust to meet other than the filter conditions (usually aux.NonTuner)
Can only be adjusted with a monster outside
●void aux.AddSynchroMixProcedure(Card c, function f1|nil, function f2|nil, function f3|nil, function f4|nil, int minc, int maxc)

●function aux.TuneMagicianFilter(Card c, Effect e)

●function aux.TuneMagicianCheckX(Card c, Group sg, Effect e)

●void aux.AddXyzProcedure(Card c, function f|nil, int lv, int ct[, function alterf|nil, int desc|nil, int maxc = ct, function op|nil])
Add an excess summon for c
With the conditions to meet the conditions for the f-level cv-maxct lv monster to be stacked
The rest of the parameters are used to stack on a single monster (usually an excess of monsters)
Alterf for this monster to meet the conditions, desc for the description, op for the stacked operation (hope Huanglong)
●void aux.AddXyzProcedureLevelFree(Card c, function f|nil, function gf|nil, int minc, int maxc[, function alterf|nil, int desc|nil, function op|nil])

●void aux.AddFusionProcMix(Card c, bool sub, bool insf,...)

●void aux.AddFusionProcMixRep(Card c, bool sub, bool insf, (function f1)|(int code1), int minc, int maxc,...)

●void aux.AddFusionProcCode2(Card c, int code1, int code2, bool sub, bool insf)
For the c designated card number for the code1 and code2 monster for the fusion material
Sub that can use fusion instead of material, insf that can be summoned with a simple fusion
●void aux.AddFusionProcCode3(Card c, int code1, int code2, int code3, bool sub, bool insf)
For the c designated card number code1, code2, code3 monster for the fusion material
●void aux.AddFusionProcCode4(Card c, int code1, int code2, int code3, int code4, bool sub, bool insf)
For the c designated card number for the code1, code2, code3, code4 monster for the fusion material
●void aux.AddFusionProcCodeRep(Card c, int code, int cc, bool sub, bool insf)
For the c designated cc the same monster for the fusion material, code for the card number
●void aux.AddFusionProcCodeRep2(Card c, int code, int minc, int maxc, bool sub, bool insf)

●void aux.AddFusionProcCodeFun(Card c, int code, function f, int cc, bool sub, bool insf)
For the c designated card number for the code and cc meet the conditions of the monster f fusion material
●void aux.AddFusionProcFun2(Card c, function f1, function f2, bool insf)
For the c to specify conditions for the f1 and f2 monsters for the fusion material
●void aux.AddFusionProcFunRep(Card c, function f, int cc, bool insf)
For the c designated cc meet the same conditions f monster for the fusion material
●void aux.AddFusionProcFunRep2(Card c, function f, int minc, int maxc, bool insf)

●void aux.AddFusionProcFunFun(Card c, function f1, function f2, int cc, bool sub, bool insf)

●void aux.AddFusionProcFunFunRep(Card c, function f1, function f2, int minc, int maxc, bool sub, bool insf)

●void aux.AddFusionProcCodeFunRep(Card c, int code, function f, int minc, int maxc, bool sub, bool insf)

●void aux.AddFusionProcCode2FunRep(Card c, int code1, int code2, function f, int minc, int maxc, bool sub, bool insf)

●void aux.AddFusionProcShaddoll(Card c, int attribute)

●Effect aux.AddContactFusionProcedure(Card c[, function filter, int self_location, int opponent_location, function mat_operation,...])

●Effect aux.AddRitualProcUltimate(Card c[, function filter, function level_function, string greater_or_equal, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcGreater(Card c, function filter[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])
Add a ritual summon effect to c
Filter for the ritual monster to meet the conditions, the material level can be more than the ritual monster level
●Effect aux.AddRitualProcGreaterCode(Card c, int code[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcEqual(Card c, function filter[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])
Add a ritual summon effect to c
Filter for the ritual monster to meet the conditions, the material level must be equal to the ritual monster level
●Effect aux.AddRitualProcEqualCode(Card c, int code[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcEqual2(Card c, function filter[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcEqual2Code(Card c, int code[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcEqual2Code2(Card c, int code1, int code2[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcGreater2(Card c, function filter[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcGreater2Code(Card c, int code1[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●Effect aux.AddRitualProcGreater2Code2(Card c, int code1, int code2[, int summon_location, function grave_filter, function mat_filter, bool pause, function extra_operation])

●void aux.EnablePendulumAttribute(Card c[, active_effect = true])

●void aux.EnableReviveLimitPendulumSummonable(Card c[, int location = 0xff])

●void aux.AddLinkProcedure(Card c, function f|nil, int minc[, int maxc = 99, function gf|nil])

●int aux.GetLinkCount(Card c)

●void aux.EnableExtraDeckSummonCountLimit()

●void aux.AddMaterialCodeList(Card c,...)

●bool aux.IsMaterialListCode(Card c, int code)

●bool aux.IsMaterialListSetCard(Card c, int setcode)

●bool aux.IsMaterialListType(Card c, int type)

●int,int aux.GetMaterialListCount(Card c)

●void aux.AddCodeList(Card c,...)

●bool aux.IsCodeListed(Card c, int code)

●void aux.AddSetNameMonsterList(Card c,...)

●void aux.IsSetNameMonsterListed(Card c, int setcode)

●bool aux.IsCounterAdded(Card c, int counter)

●bool aux.IsTypeInText(Card c, int type)

●bool aux.IsInGroup(Card c, Group g)

●int aux.GetColumn(Card c, int player = 0)

●int aux.MZoneSequence(int seq)

●int|nil aux.SZoneSequence(int seq)

●function aux.ChangeBattleDamage(int player, int value)

●bool aux.NegateMonsterFilter(Card c)

●bool aux.NegateEffectMonsterFilter(Card c)

●bool aux.NegateAnyFilter(Card c)

●bool aux.bdcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.bdocon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.bdgcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.bdogcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.dsercon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.dogcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.dogfcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.exccon(Effect e)

●bool aux.bpcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.dscon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.chainreg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.imval1(Effect e, Card c)

●bool aux.indsval(Effect e, Effect re, int rp)

●bool aux.indoval(Effect e, Effect re, int rp)

●bool aux.tgsval(Effect e, Effect re, int rp)

●bool aux.tgoval(Effect e, Effect re, int rp)

●bool aux.nzatk(Card c)

●bool aux.nzdef(Card c)

●bool aux.sumreg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.fuslimit(Effect e, Effect se, int sp, int st)

●bool aux.ritlimit(Effect e, Effect se, int sp, int st)

●bool aux.synlimit(Effect e, Effect se, int sp, int st)

●bool aux.xyzlimit(Effect e, Effect se, int sp, int st)

●bool aux.penlimit(Effect e, Effect se, int sp, int st)

●bool aux.linklimit(Effect e, Effect se, int sp, int st)

●bool aux.damcon1(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.qlifilter(Effect e, Effect te)

●bool aux.gbspcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●bool aux.evospcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)

●function aux.NecroValleyFilter(function f)

●bool aux.NecroValleyNegateCheck(v)

●Effect aux.AddUrsarcticSpSummonEffect(Card c)

●Effect aux.AddDrytronSpSummonEffect(Card c, function func)

●void aux.LabrynthDestroyOp(Effect e, int tp, int res)

●bool aux.AtkEqualsDef(Card c)

●bool aux.bfgcost(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp, int chk)

●bool aux.dncheck(Group g)

●bool aux.dlvcheck(Group g)

●bool aux.drkcheck(Group g)

●bool aux.dlkcheck(Group g)

●bool aux.dabcheck(Group g)

●bool aux.drccheck(Group g)

●bool aux.gfcheck(Group g, function f, a1, a2)

●bool aux.gffcheck(Group g, function f1, a1, function f2, a2)

●bool aux.mzctcheck(Group g, int tp)

●bool aux.mzctcheckrel(Group g, int tp)

●bool aux.ExceptThisCard(Effect e)

●int aux.GetMultiLinkedZone(int tp)

●bool Group.CheckSubGroup(Group g, function f[, int min, int max,...])

●Card|nil Group.SelectSubGroup(Group g, int tp, function f[, bool cancelable, int min, int max,...])

●table aux.CreateChecks(function f, table list)

●bool Group.CheckSubGroupEach(Group g, table checks[, function f,...])

●Group|nil Group.SelectSubGroupEach(Group g, int tp, table checks[, bool cancelable, function f,...])

●bool aux.nbcon(int tp, Effect re)

●bool|nil aux.nbtg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp, int chk)

●bool aux.ndcon(int tp, Effect re)

●function aux.tdcfop(Card c)

●int aux.SequenceToGlobal(int p, int loc, int seq)

●void aux.UseExtraReleaseCount(Group g, int tp)

●bool aux.ExtraReleaseFilter(Card c, int tp)

●bool aux.IsSpecialSummonedByEffect(Effect e)

●int aux.GetCappedLevel(Card c)

●int aux.GetCappedAttack(Card c)

●Effect aux.AddThisCardInGraveAlreadyCheck(Card c)

========== Debug ==========
●void Debug.Message(any msg)
Displays the message
●Card Debug.AddCard(int code, int owner, int player, int location, int seq, int pos[, bool proc = false])
Add a card, the card number for the card holder is set to owner, to represent the form of pos placed in the player's field is located in the location on the seq seq grid
Proc = true then lifted the Soviet students limit
●void Debug.SetPlayerInfo(int playerid, int lp, int startcount, int drawcount)
Set the player information, divided into lp, the initial hand card for the startcount Zhang, drawcount each round of pumping
Playerid below 0, top 1
●void Debug.PreSummon(Card c, int sum_type[, int sum_location = 0])
Set summon information for card c: Summarize with sum_type method (usually summoned, special summoned, etc.) [from sum_location]
●bool Debug.PreEquip(Card equip_card, Card target)
Add equip_card to the target
●void Debug.PreSetTarget(Card c, Card target)
The target selected as the perpetual object c
●void Debug.PreAddCounter(Card c, int counter_type[, int count = 0])
Add count counters_type counters for c
●void Debug.ReloadFieldBegin(int flag[, int rule = 5])
Start with the option flag
Flag: DUEL_ATTACK_FIRST_TURN + DUEL_SIMPLE_AI
●void Debug.ReloadFieldEnd()
Layout ends
●void Debug.SetAIName(string name)
Set the name of the AI
●void Debug.ShowHint(string msg)
A message box appears